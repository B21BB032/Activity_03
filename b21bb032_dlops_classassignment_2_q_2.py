# -*- coding: utf-8 -*-
"""B21BB032_DLOps_ClassAssignment_2_Q_2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zgqiZwVJzDEGE-I0CZ8Q6Z4n26fYfQwq
"""

## Import the libraries here in this cell
import numpy as np
import pandas as pd
import torch
import torchvision
import torch.nn as nn
import torch.nn.functional as F
from torchvision import transforms, datasets
import torch.optim as optim
import matplotlib.pyplot as plt
from torch.utils.data import DataLoader, TensorDataset
from sklearn import metrics
from sklearn.metrics import classification_report
import seaborn as sns
from torchvision.models import resnet18
from torch.utils.data import Subset
import torchvision.models as models

batch_size = 32
learning_rate = 3e-4
epochs = 5
image_size = 28

# Define the transformation for the dataset
transform = transforms.Compose([
    transforms.Grayscale(num_output_channels=3),  # Convert to 3 channels
    transforms.ToTensor(),
    transforms.Resize(image_size),
    transforms.Normalize((0.5,), (0.5,))
])

# Download and import the training set
train_dataset = datasets.FashionMNIST(root='./data', train=True, transform=transform, download=True)
test_data = datasets.FashionMNIST(root='./data', train=False, transform=transform, download=True)


# Splitting dataset into train, val and test sets
train_data, val_data = torch.utils.data.random_split(train_dataset, [0.8, 0.2])

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

trainloader = DataLoader(train_data, batch_size= batch_size, shuffle=True)
valloader = DataLoader(val_data, batch_size= batch_size, shuffle=False)
testloader = DataLoader(test_data, batch_size= batch_size, shuffle=False)

model = models.resnet101(pretrained=True).to(device)
model.fc = nn.Linear(model.fc.in_features, len(train_dataset.classes)).to(device)

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=3e-4)
optimizer2 = optim.Adagrad(model.parameters(), lr=3e-4)
optimizer3 = optim.RMSprop(model.parameters(), lr=3e-4)

epochs = 5
def train(model, trainloader, valloader, criterion, optimizer, device, epochs):
    model.train()

    t_loss = []
    v_loss = []

    for epoch in range(epochs):
        loss = 0
        correct_train = 0
        total_train = 0

        for inputs, labels in trainloader:
            inputs, labels = inputs.to(device), labels.to(device)
            optimizer.zero_grad()
            outputs = model(inputs)
            train_loss = criterion(outputs, labels)
            train_loss.backward()
            optimizer.step()

            loss += train_loss.item()

            _, pred = outputs.max(1)
            total_train += labels.size(0)
            correct_train += pred.eq(labels).sum().item()

        loss /= len(trainloader)
        t_loss.append(loss)

        train_accuracy = 100 * correct_train / total_train

        val_loss = 0

        with torch.no_grad():
            for inputs, label in valloader:
                inputs = inputs.to(device)
                label = label.to(device)

                outputs = model(inputs)
                valid_loss = criterion(outputs, label)
                val_loss += valid_loss.item()

        val_loss /= len(valloader)
        v_loss.append(val_loss)

        # Display the epoch losses
        print("epoch : {}/{}, recon loss = {:.8f}".format(epoch + 1, epochs, loss))
        print("epoch : {}/{}, valid loss = {:.8f}".format(epoch + 1, epochs, val_loss))

    return t_loss, v_loss, train_loss/len(trainloader), train_accuracy

def test(model, testloader, criterion, device):
    model.eval()
    correct_test = 0
    total_test = 0

    with torch.no_grad():
        for inputs, labels in testloader:
            inputs, labels = inputs.to(device), labels.to(device)

            # Forward pass
            outputs = model(inputs)

            # Calculate accuracy
            _, pred = outputs.max(1)
            total_test += labels.size(0)
            correct_test += pred.eq(labels).sum().item()

    test_accuracy = 100 * correct_test / total_test

    return test_accuracy

def plot_accuracies(train_accuracies, test_accuracies, epochs):

    # Your code here
    epochs = len(train_accuracies)
    plt.plot(range(1, epochs + 1), train_accuracies, label='Train Accuracy')
    plt.plot(range(1, epochs + 1), test_accuracies, label='Test Accuracy')

    plt.xlabel('Epochs')
    plt.ylabel('Accuracy')
    plt.title('Train and Test Accuracies vs Epochs')
    plt.legend()
    plt.show()

train_losses, val_losses, train_loss_per_batch, train_accuracy = train(model, trainloader, valloader, criterion, optimizer, device, 10)
test_accuracy = test(model, testloader, criterion, device)

train_accuracy

test_accuracy

train_accuracy = [train_accuracy] * epochs
test_accuracy = [test_accuracy] * epochs
plot_accuracies(train_accuracy, test_accuracy, epochs)

plt.plot(train_losses[2:], label='Training Loss')
plt.plot(val_losses[2:], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

train_losses, val_losses, train_loss_per_batch, train_accuracy = train(model, trainloader, valloader, criterion, optimizer2, device, 10)
test_accuracy = test(model, testloader, criterion, device)

train_accuracy

test_accuracy

train_accuracy = [train_accuracy] * epochs
test_accuracy = [test_accuracy] * epochs
plot_accuracies(train_accuracy, test_accuracy, epochs)

plt.plot(train_losses[2:], label='Training Loss')
plt.plot(val_losses[2:], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()



train_losses, val_losses, train_loss_per_batch, train_accuracy = train(model, trainloader, valloader, criterion, optimizer3, device, 10)
test_accuracy = test(model, testloader, criterion, device)

train_accuracy

test_accuracy

train_accuracy = [train_accuracy] * epochs
test_accuracy = [test_accuracy] * epochs
plot_accuracies(train_accuracy, test_accuracy, epochs)

plt.plot(train_losses[2:], label='Training Loss')
plt.plot(val_losses[2:], label='Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()
plt.show()

